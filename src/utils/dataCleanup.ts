import { supabase } from "@/integrations/supabase/client";
import type { TablesInsert } from "@/integrations/supabase/types";

// Utility to remove empty fields from an object
export function removeEmptyFields<T extends Record<string, any>>(obj: T): Partial<T> {
  return Object.fromEntries(
    Object.entries(obj).filter(([_, value]) => {
      if (Array.isArray(value)) {
        return value.length > 0;
      }
      if (value === null || value === undefined || value === '') {
        return false;
      }
      return true;
    })
  ) as Partial<T>;
}

async function getNextCollectorNumber(): Promise<string> {
  const { data: lastCollector } = await supabase
    .from('collectors')
    .select('number')
    .order('number', { ascending: false })
    .limit(1)
    .single();

  const nextNumber = lastCollector 
    ? String(Number(lastCollector.number) + 1).padStart(2, '0')
    : '01';
    
  return nextNumber;
}

// Transform member data to match Supabase schema
export function transformMemberForSupabase(memberData: any): TablesInsert<'members'> {
  const cleanedData = removeEmptyFields({
    full_name: memberData.fullName || memberData.name,
    member_number: memberData.memberNumber || '', // Will be generated by trigger
    address: memberData.address,
    email: memberData.email,
    gender: memberData.gender,
    marital_status: memberData.maritalStatus,
    phone: memberData.mobileNo,
    date_of_birth: memberData.dateOfBirth || null,
    postcode: memberData.postCode,
    town: memberData.town,
    verified: memberData.verified || false,
    status: 'active',
  });

  // Ensure required fields are present
  if (!cleanedData.full_name) {
    throw new Error('Member name is required');
  }

  console.log('Transformed member data:', cleanedData);
  return cleanedData as TablesInsert<'members'>;
}

// Transform collector data to match Supabase schema
export async function transformCollectorForSupabase(collectorName: string): Promise<TablesInsert<'collectors'>> {
  if (!collectorName) {
    throw new Error('Collector name is required');
  }

  const nameParts = collectorName.split(/[\s&-]/);
  const prefix = nameParts
    .map(part => part.substring(0, 2).toUpperCase())
    .join('');
  
  const number = await getNextCollectorNumber();

  const collectorData: TablesInsert<'collectors'> = {
    name: collectorName,
    prefix,
    number,
    active: true,
  };

  return collectorData;
}